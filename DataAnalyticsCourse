Matris.py

#Alperen Tercan and Redion Xhepa

#!/usr/bin/env python
import pygame
from pygame import Rect, Surface
import random
import os
import kezmenu
import numpy as np
import feature_calc
import Evolution
from tetrominoes import list_of_tetrominoes
from tetrominoes import rotate
from scores import load_score, write_score
from Bot import Bot
from Neural_Bot import Neural_Bot
class GameOver(Exception):
    """Exception used for its control flow properties"""

def get_sound(filename):
    return pygame.mixer.Sound(os.path.join(os.path.dirname(__file__), "resources", filename))

GAMEOVER = pygame.USEREVENT + 11

BGCOLOR = (15, 15, 20)
BORDERCOLOR = (140, 140, 140)

BLOCKSIZE = 30
BORDERWIDTH = 10

MATRIS_OFFSET = 20

MATRIX_WIDTH = 10
MATRIX_HEIGHT = 22

LEFT_MARGIN = 340

WIDTH = MATRIX_WIDTH*BLOCKSIZE + BORDERWIDTH*2 + MATRIS_OFFSET*2 + LEFT_MARGIN
HEIGHT = (MATRIX_HEIGHT-2)*BLOCKSIZE + BORDERWIDTH*2 + MATRIS_OFFSET*2

TRICKY_CENTERX = WIDTH-(WIDTH-(MATRIS_OFFSET+BLOCKSIZE*MATRIX_WIDTH+BORDERWIDTH*2))/2

VISIBLE_MATRIX_HEIGHT = MATRIX_HEIGHT - 2


class Matris(object):
    def __init__(self,game,seed):
        self.surface = screen.subsurface(Rect((MATRIS_OFFSET+BORDERWIDTH, MATRIS_OFFSET+BORDERWIDTH),
                                              (MATRIX_WIDTH * BLOCKSIZE, (MATRIX_HEIGHT-2) * BLOCKSIZE)))
        self.seed = seed
        self.matrix = dict()
        for y in range(MATRIX_HEIGHT):
            for x in range(MATRIX_WIDTH):
                self.matrix[(y,x)] = None
        """
        `self.matrix` is the current state of the tetris board, that is, it records which squares are
        currently occupied. It does not include the falling tetromino. The information relating to the
        falling tetromino is managed by `self.set_tetrominoes` instead. When the falling tetromino "dies",
        it will be placed in `self.matrix`.
        """
        self.game = game
        random.seed(self.seed)
        self.next_tetromino = random.choice(list_of_tetrominoes)
        self.set_tetrominoes()
        self.tetromino_rotation = 0
        self.downwards_timer = 0
        self.base_downwards_speed = 0.4 # Move down every 400 ms

        self.movement_keys = {'left': 0, 'right': 0}
        self.movement_keys_speed = 0.05
        self.movement_keys_timer = (-self.movement_keys_speed)*2
        
        self.moves = []
        self.level = 1
        self.score = 0
        self.lines = 0

        self.combo = 1 # Combo will increase when you clear lines with several tetrominos in a row
        
        self.paused = False

        self.highscore = load_score()
        self.played_highscorebeaten_sound = False

#        self.levelup_sound  = get_sound("levelup.wav")
#        self.gameover_sound = get_sound("gameover.wav")
#        self.linescleared_sound = get_sound("linecleared.wav")
#        self.highscorebeaten_sound = get_sound("highscorebeaten.wav")
        self.new_tetromino_here = True

    def set_tetrominoes(self):
        self.current_tetromino = self.next_tetromino
        self.next_tetromino = random.choice(list_of_tetrominoes)
        self.surface_of_next_tetromino = self.construct_surface_of_next_tetromino()
        self.tetromino_position = (0,4) if len(self.current_tetromino.shape) == 2 else (0, 3)
        self.tetromino_rotation = 0
        self.tetromino_block = self.block(self.current_tetromino.color)
        self.shadow_block = self.block(self.current_tetromino.color, shadow=True)
        self.new_tetromino_here = True
    
    def hard_drop(self):
        amount = 0
        while self.request_movement('down'):
            amount += 1
        #self.score += 10*amount

        self.lock_tetromino()


    def update(self, timepassed):
        self.needs_redraw = False
        
        pressed = lambda key: event.type == pygame.KEYDOWN and event.key == key
        unpressed = lambda key: event.type == pygame.KEYUP and event.key == key

        events = pygame.event.get()
        
        for event in events:
            if pressed(pygame.K_p):
                self.surface.fill((0,0,0))
                self.needs_redraw = True
                self.paused = not self.paused
            elif event.type == pygame.QUIT:
                self.gameover(full_exit=True)
            elif pressed(pygame.K_ESCAPE):
                self.gameover()

        if self.paused:
            return self.needs_redraw

#        for event in events:
#            if pressed(pygame.K_SPACE):
#                self.hard_drop()
#            elif pressed(pygame.K_UP) or pressed(pygame.K_w):
#                self.request_rotation()
#
#            elif pressed(pygame.K_LEFT) or pressed(pygame.K_a):
#                self.request_movement('left')
#                self.movement_keys['left'] = 1
#            elif pressed(pygame.K_RIGHT) or pressed(pygame.K_d):
#                self.request_movement('right')
#                self.movement_keys['right'] = 1
#
#            elif unpressed(pygame.K_LEFT) or unpressed(pygame.K_a):
#                self.movement_keys['left'] = 0
#                self.movement_keys_timer = (-self.movement_keys_speed)*2
#            elif unpressed(pygame.K_RIGHT) or unpressed(pygame.K_d):
#                self.movement_keys['right'] = 0
#                self.movement_keys_timer = (-self.movement_keys_speed)*2
        #print(self.new_tetromino_here)
        if not len(self.moves) == 0:
            for move in self.moves:
#                if self.moves[i] == 'SPACE' and len(self.moves) == 1:
#                    self.hard_drop()
#                    np.delete(self.moves,i,0)
                if move == "UP":
                    self.request_rotation()
    
                elif move == 'LEFT':
                    self.request_movement('left')
                    self.movement_keys['left'] = 1
                if move == 'RIGHT':
                    self.request_movement('right')
                    self.movement_keys['right'] = 1
            self.moves = []
        else:
            self.movement_keys['left'] = 0
            self.movement_keys_timer = (-self.movement_keys_speed)*2
            self.movement_keys['right'] = 0
            self.movement_keys_timer = (-self.movement_keys_speed)*2
            self.hard_drop()

        self.downwards_speed = self.base_downwards_speed ** (1 + self.level/10.)

        self.downwards_timer += timepassed
        downwards_speed = self.downwards_speed*0.10 if any([pygame.key.get_pressed()[pygame.K_DOWN],
                                                            pygame.key.get_pressed()[pygame.K_s]]) else self.downwards_speed
        if self.downwards_timer > downwards_speed:
            if not self.request_movement('down'):
                self.lock_tetromino()

            self.downwards_timer %= downwards_speed


        if any(self.movement_keys.values()):
            self.movement_keys_timer += timepassed
        if self.movement_keys_timer > self.movement_keys_speed:
            self.request_movement('right' if self.movement_keys['right'] else 'left')
            self.movement_keys_timer %= self.movement_keys_speed
        
        return self.needs_redraw

    def draw_surface(self):
        with_tetromino = self.blend(matrix=self.place_shadow())

        for y in range(MATRIX_HEIGHT):
            for x in range(MATRIX_WIDTH):

                #                                       I hide the 2 first rows by drawing them outside of the surface
                block_location = Rect(x*BLOCKSIZE, (y*BLOCKSIZE - 2*BLOCKSIZE), BLOCKSIZE, BLOCKSIZE)
                if with_tetromino[(y,x)] is None:
                    self.surface.fill(BGCOLOR, block_location)
                else:
                    if with_tetromino[(y,x)][0] == 'shadow':
                        self.surface.fill(BGCOLOR, block_location)
                    
                    self.surface.blit(with_tetromino[(y,x)][1], block_location)
                    
    def gameover(self, full_exit=False):
        """
        Gameover occurs when a new tetromino does not fit after the old one has died, either
        after a "natural" drop or a hard drop by the player. That is why `self.lock_tetromino`
        is responsible for checking if it's game over.
        """

        write_score(self.score)
        self.game.send_scores(self.score)
        
        if full_exit:
            exit()
        else:
            #self.menu.new_game()
            #self.game.gameover = True
            raise GameOver("Sucker!")

    def place_shadow(self):
        posY, posX = self.tetromino_position
        while self.blend(position=(posY, posX)):
            posY += 1

        position = (posY-1, posX)

        return self.blend(position=position, shadow=True)

    def fits_in_matrix(self, shape, position):
        posY, posX = position
        for x in range(posX, posX+len(shape)):
            for y in range(posY, posY+len(shape)):
                if self.matrix.get((y, x), False) is False and shape[y-posY][x-posX]: # outside matrix
                    return False

        return position
                    

    def request_rotation(self):
        rotation = (self.tetromino_rotation + 1) % 4
        shape = self.rotated(rotation)

        y, x = self.tetromino_position

        position = (self.fits_in_matrix(shape, (y, x)) or
                    self.fits_in_matrix(shape, (y, x+1)) or
                    self.fits_in_matrix(shape, (y, x-1)) or
                    self.fits_in_matrix(shape, (y, x+2)) or
                    self.fits_in_matrix(shape, (y, x-2)))
        # ^ That's how wall-kick is implemented

        if position and self.blend(shape, position):
            self.tetromino_rotation = rotation
            self.tetromino_position = position
            
            self.needs_redraw = True
            return self.tetromino_rotation
        else:
            return False
            
    def request_movement(self, direction):
        posY, posX = self.tetromino_position
        if direction == 'left' and self.blend(position=(posY, posX-1)):
            self.tetromino_position = (posY, posX-1)
            self.needs_redraw = True
            return self.tetromino_position
        elif direction == 'right' and self.blend(position=(posY, posX+1)):
            self.tetromino_position = (posY, posX+1)
            self.needs_redraw = True
            return self.tetromino_position
        elif direction == 'up' and self.blend(position=(posY-1, posX)):
            self.needs_redraw = True
            self.tetromino_position = (posY-1, posX)
            return self.tetromino_position
        elif direction == 'down' and self.blend(position=(posY+1, posX)):
            self.needs_redraw = True
            self.tetromino_position = (posY+1, posX)
            return self.tetromino_position
        else:
            return False

    def rotated(self, rotation=None):
        if rotation is None:
            rotation = self.tetromino_rotation
        return rotate(self.current_tetromino.shape, rotation)

    def block(self, color, shadow=False):
        colors = {'blue':   (105, 105, 255),
                  'yellow': (225, 242, 41),
                  'pink':   (242, 41, 195),
                  'green':  (22, 181, 64),
                  'red':    (204, 22, 22),
                  'orange': (245, 144, 12),
                  'cyan':   (10, 255, 226)}


        if shadow:
            end = [90] # end is the alpha value
        else:
            end = [] # Adding this to the end will not change the array, thus no alpha value

        border = Surface((BLOCKSIZE, BLOCKSIZE), pygame.SRCALPHA, 32)
        border.fill(list(map(lambda c: c*0.5, colors[color])) + end)

        borderwidth = 2

        box = Surface((BLOCKSIZE-borderwidth*2, BLOCKSIZE-borderwidth*2), pygame.SRCALPHA, 32)
        boxarr = pygame.PixelArray(box)
        for x in range(len(boxarr)):
            for y in range(len(boxarr)):
                boxarr[x][y] = tuple(list(map(lambda c: min(255, int(c*random.uniform(0.8, 1.2))), colors[color])) + end) 

        del boxarr # deleting boxarr or else the box surface will be 'locked' or something like that and won't blit.
        border.blit(box, Rect(borderwidth, borderwidth, 0, 0))


        return border

    def lock_tetromino(self):
        """
        This method is called whenever the falling tetromino "dies". `self.matrix` is updated,
        the lines are counted and cleared, and a new tetromino is chosen.
        """
        self.matrix = self.blend()

        lines_cleared = self.remove_lines()
        self.lines += lines_cleared

        if lines_cleared:
#            if lines_cleared >= 4:
#                self.linescleared_sound.play()
            self.score += 100 * (lines_cleared**2)# * self.combo

#            if not self.played_highscorebeaten_sound and self.score > self.highscore:
 #               if self.highscore != 0:
#                    self.highscorebeaten_sound.play()
#                self.played_highscorebeaten_sound = True

        if self.lines >= self.level*10:
#            self.levelup_sound.play()
            self.level += 1

        self.combo = self.combo + 1 if lines_cleared else 1

        self.set_tetrominoes()

        if not self.blend():
#            self.gameover_sound.play()
            self.gameover()
            
        self.needs_redraw = True
        self.score += 20
    def remove_lines(self):
        lines = []
        for y in range(MATRIX_HEIGHT):
            line = (y, [])
            for x in range(MATRIX_WIDTH):
                if self.matrix[(y,x)]:
                    line[1].append(x)
            if len(line[1]) == MATRIX_WIDTH:
                lines.append(y)

        for line in sorted(lines):
            for x in range(MATRIX_WIDTH):
                self.matrix[(line,x)] = None
            for y in range(0, line+1)[::-1]:
                for x in range(MATRIX_WIDTH):
                    self.matrix[(y,x)] = self.matrix.get((y-1,x), None)

        return len(lines)

    def blend(self, shape=None, position=None, matrix=None, shadow=False):
        """
        Does `shape` at `position` fit in `matrix`? If so, return a new copy of `matrix` where all
        the squares of `shape` have been placed in `matrix`. Otherwise, return False.
        
        This method is often used simply as a test, for example to see if an action by the player is valid.
        It is also used in `self.draw_surface` to paint the falling tetromino and its shadow on the screen.
        """
        if shape is None:
            shape = self.rotated()
        if position is None:
            position = self.tetromino_position

        copy = dict(self.matrix if matrix is None else matrix)
        posY, posX = position
        for x in range(posX, posX+len(shape)):
            for y in range(posY, posY+len(shape)):
                if (copy.get((y, x), False) is False and shape[y-posY][x-posX] # shape is outside the matrix
                    or # coordinate is occupied by something else which isn't a shadow
                    copy.get((y,x)) and shape[y-posY][x-posX] and copy[(y,x)][0] != 'shadow'):

                    return False # Blend failed; `shape` at `position` breaks the matrix

                elif shape[y-posY][x-posX]:
                    copy[(y,x)] = ('shadow', self.shadow_block) if shadow else ('block', self.tetromino_block)

        return copy

    def construct_surface_of_next_tetromino(self):
        shape = self.next_tetromino.shape
        surf = Surface((len(shape)*BLOCKSIZE, len(shape)*BLOCKSIZE), pygame.SRCALPHA, 32)

        for y in range(len(shape)):
            for x in range(len(shape)):
                if shape[y][x]:
                    surf.blit(self.block(self.next_tetromino.color), (x*BLOCKSIZE, y*BLOCKSIZE))
        return surf
    
    def get_matrix(self):
        return self.matrix
    
    def set_events(self,moves):
        self.moves = moves
    def set_menu(self,menu):
        self.menu = menu
        
class Game(object):
    def __init__(self,bot,menu,seed):
        self.seed = seed
        self.bot = bot
        self.menu = menu
        self.gameover = False
        
    def main(self, screen):
        clock = pygame.time.Clock()
        bot = self.bot
        menu = self.menu
        self.matris = Matris(self,self.seed)
        self.matris.set_menu(menu)
        screen.blit(construct_nightmare(screen.get_size()), (0,0))      
        matris_border = Surface((MATRIX_WIDTH*BLOCKSIZE+BORDERWIDTH*2, VISIBLE_MATRIX_HEIGHT*BLOCKSIZE+BORDERWIDTH*2))
        matris_border.fill(BORDERCOLOR)
        screen.blit(matris_border, (MATRIS_OFFSET,MATRIS_OFFSET))              
        self.redraw()

        while True:
            try:
                timepassed = clock.tick(100) #50
                if self.matris.update((timepassed / 1000.) if not self.matris.paused else 0):
                    self.redraw()
                    if(self.matris.new_tetromino_here):
                        bot.set_matrix(self.matris.get_matrix())
                        position,shape = bot.best_move(self.matris.current_tetromino)
                        moves = bot.move_tetr(self.matris.current_tetromino,position,shape)
                        #print(self.matris.current_tetromino.name)
                        self.matris.set_events(moves)
                        self.matris.new_tetromino_here = False
            except GameOver:
                return True
     
    def send_scores(self,score):
        self.bot.save_score(score)
        
    def redraw(self):
        if not self.matris.paused:
            self.blit_next_tetromino(self.matris.surface_of_next_tetromino)
            self.blit_info()

            self.matris.draw_surface()

        pygame.display.flip()

    def blit_info(self):
        textcolor = (255, 255, 255)
        font = pygame.font.Font(None, 30)
        width = (WIDTH-(MATRIS_OFFSET+BLOCKSIZE*MATRIX_WIDTH+BORDERWIDTH*2)) - MATRIS_OFFSET*2

        def renderpair(text, val):
            text = font.render(text, True, textcolor)
            val = font.render(str(val), True, textcolor)

            surf = Surface((width, text.get_rect().height + BORDERWIDTH*2), pygame.SRCALPHA, 32)

            surf.blit(text, text.get_rect(top=BORDERWIDTH+10, left=BORDERWIDTH+10))
            surf.blit(val, val.get_rect(top=BORDERWIDTH+10, right=width-(BORDERWIDTH+10)))
            return surf

        scoresurf = renderpair("Score", self.matris.score)
        levelsurf = renderpair("Level", self.matris.level)
        linessurf = renderpair("Lines", self.matris.lines)
        combosurf = renderpair("Combo", "x{}".format(self.matris.combo))

        height = 20 + (levelsurf.get_rect().height + 
                       scoresurf.get_rect().height +
                       linessurf.get_rect().height + 
                       combosurf.get_rect().height )

        area = Surface((width, height))
        area.fill(BORDERCOLOR)
        area.fill(BGCOLOR, Rect(BORDERWIDTH, BORDERWIDTH, width-BORDERWIDTH*2, height-BORDERWIDTH*2))

        area.blit(levelsurf, (0,0))
        area.blit(scoresurf, (0, levelsurf.get_rect().height))
        area.blit(linessurf, (0, levelsurf.get_rect().height + scoresurf.get_rect().height))
        area.blit(combosurf, (0, levelsurf.get_rect().height + scoresurf.get_rect().height + linessurf.get_rect().height))

        screen.blit(area, area.get_rect(bottom=HEIGHT-MATRIS_OFFSET, centerx=TRICKY_CENTERX))


    def blit_next_tetromino(self, tetromino_surf):
        area = Surface((BLOCKSIZE*5, BLOCKSIZE*5))
        area.fill(BORDERCOLOR)
        area.fill(BGCOLOR, Rect(BORDERWIDTH, BORDERWIDTH, BLOCKSIZE*5-BORDERWIDTH*2, BLOCKSIZE*5-BORDERWIDTH*2))

        areasize = area.get_size()[0]
        tetromino_surf_size = tetromino_surf.get_size()[0]
        # ^^ I'm assuming width and height are the same

        center = areasize/2 - tetromino_surf_size/2
        area.blit(tetromino_surf, (center, center))

        screen.blit(area, area.get_rect(top=MATRIS_OFFSET, centerx=TRICKY_CENTERX))
        
    def get_matrix(self):
        return self.matris.get_matrix()

class Menu(object):
    def __init__(self,seed):
        self.MAX_GAMES = 25 
        self.games_so_far = 0
        self.scores = []
        self.gameover = False
        self.seeds = seed
        
    running = True
     
    def main(self, screen,bot_mode):
        clock = pygame.time.Clock()
        if bot_mode == "Neural": 
            self.bot = Neural_Bot()
        else:
            self.bot = Bot()
        menu = kezmenu.KezMenu(
            ['Play!', lambda: self.game_create(menu) ],
            ['Quit', lambda: setattr(self, 'running', False)],event_gameover = GAMEOVER
            )       
        menu.position = (50, 50)
        menu.enableEffect('enlarge-font-on-focus', font=None, size=60, enlarge_factor=1.2, enlarge_time=0.3)
        menu.color = (255,255,255)
        menu.focus_color = (40, 200, 40)
        nightmare = construct_nightmare(screen.get_size())
        highscoresurf = self.construct_highscoresurf()
        timepassed = clock.tick(30) / 1000.
        print("New Game")
        while self.running:
    
            events = pygame.event.get()

            for event in events:
                if event.type == pygame.QUIT:
                    exit()

            menu.update(self.gameover,events, timepassed)
            timepassed = clock.tick(30) / 1000. #30 original           
            if timepassed > 1: # A game has most likely been played 2e
                highscoresurf = self.construct_highscoresurf()

            screen.blit(nightmare, (0,0))
            screen.blit(highscoresurf, highscoresurf.get_rect(right=WIDTH-50, bottom=HEIGHT-50))
            menu.draw(screen) 
            pygame.display.flip()
    
    def game_create(self,menu):
        if(self.games_so_far<self.MAX_GAMES):
            self.game = Game(self.bot,menu,self.seeds[self.games_so_far])
            self.games_so_far = self.games_so_far + 1
            self.gameover = self.game.main(screen)
        else:
            self.next_agent()
            self.game = Game(self.bot,menu)
            self.gameover = self.game.main(screen)
          
    
    def next_agent(self):
        self.games_so_far = 1;
        self.bot.next_agent()
        #self.game_create(menu)
#        
#    def evolution_start(self):
#        self.evolution = Evolution()
    
    def construct_highscoresurf(self):
        font = pygame.font.Font(None, 50)
        highscore = load_score()
        text = "Highscore: {}".format(highscore)
        return font.render(text, True, (255,255,255))
    
#    def get_matrix(self):
#        return self.game.get_matrix()
    
def construct_nightmare(size):
    surf = Surface(size)

    boxsize = 8
    bordersize = 1
    vals = '1235' # only the lower values, for darker colors and greater fear
    arr = pygame.PixelArray(surf)
    for x in range(0, len(arr), boxsize):
        for y in range(0, len(arr[x]), boxsize):

            color = int(''.join([random.choice(vals) + random.choice(vals) for _ in range(3)]), 16)

            for LX in range(x, x+(boxsize - bordersize)):
                for LY in range(y, y+(boxsize - bordersize)):
                    if LX < len(arr) and LY < len(arr[x]):
                        arr[LX][LY] = color
    del arr
    return surf


if __name__ == '__main__':
    bot_name  = "Neeeural"
    random_seeds = [101,147,179,279,231,297,321,357,387,407,421,473,
                    541,583,503,613,637,691,723,757,789,823,837,873,913]
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("MaTris")
    menu = Menu(random_seeds)
    menu.main(screen,bot_name)

matris_for_q.py

(Almost same with above, following is the main difference)

       initial  = True
        while True:
            try:
                timepassed = clock.tick(100) #50
                if self.matris.update((timepassed / 1000.) if not self.matris.paused else 0):
                    self.redraw()
                    if(self.matris.new_tetromino_here):
                        #reward = self.matris.score - current_score - 320
                        bot.set_matrix(self.matris.get_matrix(),False)
                        bot.setScore(self.matris.score,False)
                        if not initial:
                            reward = bot.calcReward(table)
                            bot.update_Q_matrix(table,self.matris.current_tetromino,reward)
                        shape,position,table = bot.best_move(self.matris.current_tetromino)
                        bot.set_matrix(self.matris.get_matrix(),True)
                        bot.setScore(self.matris.score,True)
                        moves = bot.move_tetr(self.matris.current_tetromino,shape,position,table)
                        #print(self.matris.current_tetromino.name)
                        self.matris.set_events(moves)
                        self.matris.new_tetromino_here = False
                        initial = False
           except GameOver:


bot_functions.py

import numpy as np

dict_tetr_len = {"long":[4,1,4,1],
                 "square" : [2,2,2,2],
                 "hat" : [3,2,3,2],
                 "left_snake" : [3,2,3,2],
                 "right_snake" : [3,2,3,2],
                 "left_gun" : [3,2,3,2],
                 "right_gun" : [3,2,3,2]}

dict_tetr_shape = {"long":2,
                 "square" : 1,
                 "hat" : 4,
                 "left_snake" : 2,
                 "right_snake" : 2,
                 "left_gun" : 4,
                 "right_gun" : 4}

def drop_tetr(matrix,tetromino,col,rotation):
    m = matrix.copy()
    game_over = False
    if tetromino.name == 'long':
        if rotation % 2 == 0  :
            if np.sum(m[:,col:col+4]) == 0:
                m[-1:,col:col+4] = 1
            else:
                q = m[:,col] + m[:,col+1] + m[:,col+2] + m[:,col+3]
                q = (q>=1)
                i = q.argmax(axis = 0)
                if i - 2 < 1:
                    game_over = True
                else:
                    m[i-1:i,col:col+4] = 1
        else:
            if np.sum(m[:,col]) == 0:
                m[-4:,col] = 1
            else:
                q = m[:,col]
                i = q.argmax(axis = 0)
                if i - 2 < 4:
                    game_over = True
                else:
                    m[i-4:i,col] = 1
            
            
    elif tetromino.name == 'square':
        if np.sum(m[:,col:col+2]) == 0:
            m[-2:,col:col+2] = 1
        else:
            q = m[:,col] + m[:,col+1]
            q = (q>=1)
            i = q.argmax(axis = 0)
            if i - 2 < 2:
                game_over = True
            else:
                m[i-2:i,col:col+2] = 1
            
              
    elif tetromino.name == 'hat':
          if rotation % 4 == 0:
                if np.sum(m[:,col:col+3]) == 0:
                    m[-1,col:col+3] = 1
                    m[-2,col+1]  = 1
                else:
                    q = np.sum(m[:,col:col+3],axis = 1)
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i-2,col+1]  = 1       
          elif rotation % 4 == 1:
              if np.sum(m[1:,col] + m[:-1,col+1]) == 0:
                    m[-1,col] = 1
                    m[-2,col:col+2]  = 1
                    m[-3,col]  = 1
              else:
                    q = m[1:,col] + m[:-1,col+1]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 2:
                        game_over = True
                    else: 
                        m[i-2:i+1,col] = 1
                        m[i-1,col+1] = 1
          elif rotation % 4 == 2:
                if np.sum(m[:-1,col] + m[1:,col+1] + m[:-1,col+2]) == 0:
                    m[-2,col:col+3] = 1
                    m[-1,col+1]  = 1
                else:
                    q = m[:-1,col] + m[1:,col+1] + m[:-1,col+2]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i,col+1] = 1
          elif rotation % 4 == 3:
              if np.sum(m[1:,col+1] + m[:-1,col]) == 0:
                    m[-1,col+1] = 1
                    m[-2,col:col+2]  = 1
                    m[-3,col+1]  = 1
              else:
                    q = m[1:,col+1] + m[:-1,col]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 2:
                        game_over = True
                    else: 
                        m[i-2:i+1,col+1] = 1
                        m[i-1,col] = 1   
                      
    elif tetromino.name == 'right_snake':
            if rotation % 2 == 0:
                  if np.sum(m[1:,col] + m[1:,col+1] + m[:-1,col+2]) == 0:
                        m[-1,col:col+2] = 1
                        m[-2,col+1:col+3]  = 1
                  else:
                        q = m[1:,col] + m[1:,col+1] + m[:-1,col+2]
                        q = (q>=1)
                        i = q.argmax(axis = 0)
                        if i - 2 < 1:
                            game_over = True
                        else: 
                            m[i-1,col+1:col+3] = 1
                            m[i,col:col+2] = 1   
            elif rotation % 2 == 1: 
                  if np.sum(m[1:,col+1] + m[:-1,col]) == 0:
                        m[-1,col+1] = 1
                        m[-2,col:col+2]  = 1
                        m[-3,col] = 1
                  else:
                        q = m[1:,col+1]  + m[:-1,col]
                        q = (q>=1)
                        i = q.argmax(axis = 0)
                        if i - 2 < 2:
                            game_over = True
                        else: 
                            m[i-2:i,col] = 1
                            m[i-1:i+1,col+1] = 1  
            
    elif tetromino.name == 'left_snake':
            if rotation % 2 == 0:
              if np.sum(m[1:,col+1] + m[1:,col+2] + m[:-1,col]) == 0:
                    m[-2,col:col+2] = 1
                    m[-1,col+1:col+3]  = 1
              else:
                    q = m[1:,col+1] + m[1:,col+2] + m[:-1,col]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i,col+1:col+3] = 1
                        m[i-1,col:col+2] = 1   
            elif rotation % 2 == 1: 
              if np.sum(m[1:,col] + m[:-1,col+1]) == 0:
                    m[-1,col] = 1
                    m[-2,col:col+2]  = 1
                    m[-3,col+1] = 1
              else:
                    q = m[1:,col]  + m[:-1,col+1]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 2:
                        game_over = True
                    else: 
                        m[i-2:i,col+1] = 1
                        m[i-1:i+1,col] = 1    

                      
    elif tetromino.name == 'left_gun':
         if rotation%4 == 0:
              if np.sum(m[:,col:col+3]) == 0:
                    m[-1,col:col+3] = 1
                    m[-2,col]  = 1
              else:
                    q = m[:,col] + m[:,col+1] + m[:,col+2]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 2:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i-2,col] = 1               
         if rotation%4 == 1:
              if np.sum(m[2:,col] + m[:-2,col+1]) == 0:
                    m[-1,col] = 1
                    m[-2,col]  = 1
                    m[-3,col:col+2] = 1
              else:
                    q = m[2:,col] + m[:-2,col+1]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1:i+2,col] = 1
                        m[i-1,col+1] = 1                     
         if rotation%4 == 2:
              if np.sum(m[:-1,col] + m[:-1,col+1] + m[1:,col+2]) == 0:
                    m[-1,col+2] = 1
                    m[-2,col:col+3]  = 1
              else:
                    q = m[:-1,col] + m[:-1,col+1] + m[1:,col+2]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i,col+2] = 1               
         if rotation%4 == 3:
              if np.sum(m[:,col:col+2]) == 0:
                    m[-3,col+1] = 1
                    m[-2,col+1]  = 1
                    m[-1,col:col+2] = 1
              else:
                    q = m[:,col] + m[:,col+1]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 3:
                        game_over = True
                    else: 
                        m[i-3:i,col+1] = 1
                        m[i-1,col] = 1             
              
    elif tetromino.name == 'right_gun':
         if rotation%4 == 0:
              if np.sum(m[:,col:col+3]) == 0:
                    m[-1,col:col+3] = 1
                    m[-2,col+2]  = 1
              else:
                    q = m[:,col] + m[:,col+1] + m[:,col+2]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 2:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i-2,col+2] = 1               
         if rotation%4 == 3:
              if np.sum(m[2:,col+1] + m[:-2,col]) == 0:
                    m[-1,col+1] = 1
                    m[-2,col+1]  = 1
                    m[-3,col:col+2] = 1
              else:
                    q = m[2:,col+1] + m[:-2,col]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1:i+2,col+1] = 1
                        m[i-1,col] = 1                     
         if rotation%4 == 2:
              if np.sum(m[:-1,col+1] + m[:-1,col+2] + m[1:,col]) == 0:
                    m[-1,col] = 1
                    m[-2,col:col+3]  = 1
              else:
                    q = m[:-1,col+2] + m[:-1,col+1] + m[1:,col]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 1:
                        game_over = True
                    else: 
                        m[i-1,col:col+3] = 1
                        m[i,col] = 1               
         if rotation%4 == 1:
              if np.sum(m[:,col:col+2]) == 0:
                    m[-3,col] = 1
                    m[-2,col]  = 1
                    m[-1,col:col+2] = 1
              else:
                    q = m[:,col] + m[:,col+1]
                    q = (q>=1)
                    i = q.argmax(axis = 0)
                    if i - 2 < 3:
                        game_over = True
                    else: 
                        m[i-3:i,col] = 1
                        m[i-1,col+1] = 1   
    return m,game_over


def sim_board(matrix):
    lines_cleared = 0
    for i in range(matrix.shape[0]):
        if sum(matrix[i,:]) == 10:
            lines_cleared = lines_cleared + 1
            matrix = np.delete(matrix,i,0)
            new_line = np.zeros((1,matrix.shape[1]))
            matrix = np.append(new_line,matrix,0)
    return (lines_cleared,matrix)
   

Feature_calc.py

# -*- coding: utf-8 -*-
"""
Created on Fri Dec  7 11:27:22 2018

@author: Alperen
"""

import numpy as np
import bot_functions


def convert2NumpyMatrix(dictionarymatrix):
    allocate_array=[]
    for key in dictionarymatrix:
        
        if (dictionarymatrix[key] is None ):
          allocate_array=np.append(allocate_array,0)
        else :
          allocate_array=np.append(allocate_array,1)
    allocate_array=np.reshape(allocate_array,(22,10))     
    return allocate_array

def eval_possible_states(matrix,tetromino,weight):
    #weight = weight[:-1]
    matrix_array = convert2NumpyMatrix(matrix)
#    matrix_array = matrix
    shape_tetr = bot_functions.dict_tetr_shape[tetromino.name]
    #length_tetr = bot_functions.dict_tetr_len[tetromino.name]
    score = 0
    best = -20000000000
    move = [0,0]
    for j in range(shape_tetr):
        length_tetr = bot_functions.dict_tetr_len[tetromino.name][j]
        for i in range(matrix_array.shape[1]-length_tetr+1):
            lines_cleared,matrix,gameover = future_matrix_calc(matrix_array,tetromino,i,j)
            score = np.dot(calc_all_features(matrix,lines_cleared,gameover).reshape(1,-1),weight)
            if(score > best):
                best = score
                move = [i,j]
            #scores = np.append(scores,score)
    return move

def eval_possible_states_neural(matrix,tetromino,weight,nnet):
    #weight = weight[:-1]
    matrix_array = convert2NumpyMatrix(matrix)
#    matrix_array = matrix
    shape_tetr = bot_functions.dict_tetr_shape[tetromino.name]
    #length_tetr = bot_functions.dict_tetr_len[tetromino.name]
    score = 0
    best = -20000000000
    move = [0,0]
    for j in range(shape_tetr):
        length_tetr = bot_functions.dict_tetr_len[tetromino.name][j]
        for i in range(matrix_array.shape[1]-length_tetr+1):
            lines_cleared,matrix,gameover = future_matrix_calc(matrix_array,tetromino,i,j)
            score = nnet.forward_prop('sigmoid',calc_all_features(matrix,lines_cleared,gameover),3)
            if(score > best):
                best = score
                move = [i,j]
            #scores = np.append(scores,score)
    return move


def future_matrix_calc(matrix,tetromino,col,rotation):
    m,gameover = bot_functions.drop_tetr(matrix,tetromino,col,rotation)
    lines_cleared,matrix = bot_functions.sim_board(m)
    return (lines_cleared,matrix,gameover)

def calc_all_features(matrix,lines,gameover):
    features = []
    features = np.append(features,calc_weighted_blocks(matrix)/2)
    features = np.append(features,calc_number_holes(matrix))
    features = np.append(features,calc_number_conn_holes(matrix))
    features = np.append(features,lines)
    features = np.append(features,calc_roughness(matrix))
    features = np.append(features,lines//4)
    features = np.append(features,pitHolePercentCenter(matrix))
    features = np.append(features,clearableLine(matrix))
    features = np.append(features,22 - deepestWell(matrix))
    features = np.append(features,numColHoles(matrix))
    features = np.append(features,int(gameover))
    
    #print(features)
    return features

def partialLine(matrix,col1,col2):
    rows = np.sum(matrix[:,col1:col2],axis = 1)
    lines = (rows == (col2-col1))
    return np.sum(lines)
    

def numColHoles(array_tetris):
    number_rows=array_tetris.shape[0]
    number_columns=array_tetris.shape[1]
    number_colums_with_holes=0
    for i in range(number_columns):
        isColumn=False
        for j in range (number_rows):
            #check if a column starts
            if array_tetris[j,i] ==1 :
                isColumn=True
            if isColumn==True and array_tetris[j,i] ==0:
                number_colums_with_holes=number_colums_with_holes+1
                break
    return number_colums_with_holes

def pitHolePercentCenter(array_tetris):
    number_rows=array_tetris.shape[0]
    number_columns=array_tetris.shape[1]
    numnerOFpits=0
      #find the number of pits
    for i in range(0,number_columns): #traverse each columns
        for j in  range(0,number_rows): #traverse each row
            if(array_tetris[j,i]==1):# otherwise it might create a hole
                break
             #check the borders
            if(i==0 and array_tetris[j,0]==0 and array_tetris[j,1]==1 ):
                numnerOFpits=numnerOFpits+1
                continue
            #check the borders
            if( i== 9 and array_tetris[j,9]==0 and array_tetris[j,8]==1 ):
                numnerOFpits=numnerOFpits+1
                continue
            if(array_tetris[j,i]==0 and array_tetris[j,i-1]==1 and array_tetris[j,i+1]==1 ):
                 numnerOFpits=numnerOFpits+1
    #find the number of holes
    holes = calc_number_holes(array_tetris)
    return numnerOFpits/(numnerOFpits + holes) if not (numnerOFpits + holes) == 0 else 0

def clearableLine(array_tetris):
       sum_rows=np.sum(array_tetris, axis=0)
       indeces=[]
       for i in sum_rows:
           if i==6:
               indeces=np.append(indeces,i)
       #we know the candidate rows, we will select the lowest one
       if(len(indeces) == 0):
           lines=0
       else :
           lines=1 
       return lines
   
def deepestWell(array_tetris):
     #take the shape of the array
    number_rows=array_tetris.shape[0]
    number_columns=array_tetris.shape[1]
    maximum_uptoknow=0
    for i in range(number_columns):
        temporary_max_column=0
        for j in range(number_rows):
            if (array_tetris[j,i]==0):
                temporary_max_column=j
            else:
                break
        #assign the new row
        if(temporary_max_column>maximum_uptoknow):
           maximum_uptoknow=temporary_max_column
    return maximum_uptoknow

def create_weight_vector(low,high,size):
    return np.random.uniform(low,high,size)


def average_height(matrix):
    sum_sf = 0
    for i in range(matrix.shape[1]):
        sum_sf = sum_sf + (22-matrix[:,i].argmax(axis = 0))
    sum_sf = sum_sf / matrix.shape[1]
    return sum_sf
   
def calc_weighted_blocks(matrix):
    sum_sf = 0
    for i in range(matrix.shape[0]):
        sum_sf = sum_sf + (matrix.shape[0]-i)*np.sum(matrix[i,:])
    return sum_sf

def calc_number_holes(matrix):
    count = 0
    for i in range(matrix.shape[1]):
        for j in range(matrix.shape[0]):
            if (matrix[j,i]== 0) and not(np.sum(matrix[:j,i]) == 0):
                count = count + 1
    return count

def calc_roughness(matrix):
    roughness = 0
    skyline= []
    for i in range(matrix.shape[1]-1):
        top = matrix.shape[0]
        j = 0
        while j < matrix.shape[0] and matrix[j,i] == 0:
            j = j + 1
            top = top-1
        np.append(skyline,top)
    for i in range(len(skyline)):
        roughness = roughness + abs(skyline[i] - skyline[i+1])
    return roughness
        
def calc_number_conn_holes(matrix):
    count = 0
    for i in range(matrix.shape[1]):
        if np.equal(matrix[-2:,i],[0,0]).all() and not(np.sum(matrix[:,i]) == 0):
                count = count + 1
        for j in range(1,matrix.shape[0]-1):
            if np.equal(matrix[j-1:j+2,i],[0,0,1]).all() and not(np.sum(matrix[:j,i]) == 0):
                count = count + 1
    return count 
    
mt = np.zeros((22,10))
ind_arr = [(21,4),(21,5),(21,7),(21,8),(21,9),(20,4),(19,4),(18,4)]
ind_arr2 = [(21,3),(21,4),(21,5),(21,7),(21,8),(21,9),(20,4),(19,4),(18,4),
            (18,3),(18,2),(17,3),(16,3),(16,2),(20,8),(19,8),(18,8),(18,7)]

for ind in ind_arr:
    mt[ind] = 1
import tetrominoes
tetromino = tetrominoes.list_of_tetrominoes[0]
mt2 = bot_functions.drop_tetr(mt,tetromino,0,3)
q = calc_weighted_blocks(mt)
holes = calc_number_holes(mt)
conn_holes = calc_number_conn_holes(mt)
length_tetr = bot_functions.dict_tetr_len[tetromino.name][0]
print(length_tetr)

Bot.py


import feature_calc
import numpy as np
import Evolution
class Bot(object):

    def __init__(self):
        self.game = None;
        self.MAX_ITERATIONS = 80
        self.POP_SIZE = 10
        self.INITIAL = 1
        self.gene_number = 11
        self.pop,self.labels = Evolution.create_initial_population(self.POP_SIZE*self.INITIAL,self.gene_number)
#        self.pop[:] = [[-3.57186],[0.34468494],[-0.44975404],[0.37229567],[-0.63908 ],
#                 [-1.88027692],[-0.74647466],[ 1.25289468],[-1.1205533],[-0.00261427],[0]]
#        self.pop[:] = [[-0.53854854], [-1.60903557],  [1.56770598], [-2.28885673],  [0.83760923],  [0.53685226],
# [-1.75321933], [1.45448524], [ 0.14393141],[ -0.44144691], [ 0.82662996]]
        self.pop[:] =[[-0.7729166],[-1.66007687],[1.43303584],[-3.48686149],[0.63306077],[0.09769052],
         [-2.11997579],[0.80672387],[-0.06324216],[-0.64053525],[0.22088197]]
        self.pop[:] =[[-0.84876553],[ -0.95773762],[1.4080699],[-2.32832832],[1.30429547],[-1.43197305],
                 [-0.63502829],[1.50546105],[-0.12530199],[-1.70731413],[-1.01129018]]

        print(self.pop.shape)
#        self.pop[0,:] = -8
#        self.pop[3,:] = 8

        self.scores = []
        print('Bot Created')
        self.gen_scores = []
        self.gen_scores_save = []
        self.all_scores=[]
        self.pop_index = 0
        self.iteration_index = 0
        self.weight = self.pop[:,self.pop_index]
#        print(self.weight)
        self.new_gen = False
                    
    def best_move(self,tetr):
        position,shape = feature_calc.eval_possible_states(self.matrix,tetr,self.weight)
        #position = int(np.argmax(scores)/4)
        #shape = np.argmax(scores)%4
        if (tetr.name) == 'long':
            position = position
        return (position,shape)
    
    def move_tetr(self,tetr,position,shape):
        moves = []
        #print(position)
        for j in range(shape):
            moves = np.append(moves,'UP')
        
        if tetr.name == 'long' and shape%2 == 1:
            position = position - 2
        elif tetr.name == 'left_gun' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'hat' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'left_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_gun' and shape%4 == 1:
            position = position -1

        if tetr.name == 'square':
            if  position < 4:
                for i in range(4-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-4):
                    moves = np.append(moves,'RIGHT')
        else:
            if  position < 4:
                for i in range(3-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-3):
                    moves = np.append(moves,'RIGHT')
        #moves = np.append(moves,'SPACE')
        #print('Time to move')
        return moves

    def next_agent(self):
        print(self.scores)
        if self.iteration_index == 0:
            if not self.new_gen:
                self.gen_scores = np.append(self.gen_scores,np.mean(self.scores))
                self.gen_scores_save = np.append(self.gen_scores_save,self.scores)
            self.scores = []
            if self.pop_index < self.POP_SIZE*self.INITIAL-1:
                self.pop_index += 1
                self.weight = self.pop[:,self.pop_index]
                print(self.weight)
                self.new_gen = False
                #self.weight = np.load('One_best.npy')
                #self.weight = np.load('best_gene.npy')
            else:
                self.next_gen()
        else:
            if not self.new_gen:
                self.gen_scores = np.append(self.gen_scores,np.mean(self.scores))
                self.gen_scores_save = np.append(self.gen_scores_save,self.scores)
            self.scores = []
            if self.pop_index < self.POP_SIZE-1:
                self.pop_index += 1
                self.weight = self.pop[:,self.pop_index]
                print(self.weight)
                self.new_gen = False
                #self.weight = np.load('best_gene_new1.npy')
                #self.weight = np.load('One_best.npy')
            else:
                self.next_gen()
    
    def next_gen(self):
        name_score = 'scores_of_gen' + str(self.iteration_index)
        np.save(name_score,self.gen_scores_save)        
        self.new_gen = True
        if self.iteration_index == 0:
            print('New generation : ', self.iteration_index, ' . Best of previous gen : ',np.max(self.gen_scores), 
                  ' .Average of generation : ', np.mean(self.gen_scores))
            self.iteration_index += 1
            self.pop,self.labels = Evolution.create_next_gen_hard(self.gen_scores,self.pop,1/self.INITIAL,self.labels)
#            self.pop,self.labels = Evolution.create_next_gen(self.gen_scores,self.pop,self.labels)
            self.pop_index = -1
            #self.all_scores = np.append(self.all_scores,self.gen_scores,0)
            self.gen_scores = []
            self.gen_scores_save = []
            self.next_agent()
        
        elif self.iteration_index < self.MAX_ITERATIONS:
            print('New generation : ', self.iteration_index, ' . Best of previous gen : ',np.max(self.gen_scores), 
                  ' .Average of generation : ', np.mean(self.gen_scores))
            self.iteration_index += 1
            self.pop,self.labels = Evolution.create_next_gen(self.gen_scores,self.pop,self.labels)
            self.pop_index = -1
            self.all_scores = np.append(self.all_scores,self.gen_scores,0)
            self.gen_scores = []
            self.gen_scores_save = [] 
            if self.iteration_index % 5 == 0:
                name = 'scores' + str(self.iteration_index)
                np.save(name,self.all_scores)
                name_genes = 'genes' + str(self.iteration_index)
                np.save(name_genes,self.pop)
                name_score = 'scores_for_gen' + str(self.iteration_index)
                np.save(name_score,self.gen_scores)
            self.next_agent()

        else:
            np.save('scores',self.all_scores)
            while True:
                i = 1
        
    def save_score(self,score):
        self.scores = np.append(self.scores,score)
        
    def set_matrix(self,matrix):
        self.matrix = matrix


Neural_Bot.py

# -*- coding: utf-8 -*-
"""
Created on Mon Dec 24 19:36:00 2018

@author: Alperen
"""


import feature_calc
import numpy as np
import Evolution
from NNets import NNets

class Neural_Bot(object):
    
    def __init__(self):
        self.game = None;
        self.MAX_ITERATIONS = 80
        self.POP_SIZE = 20
        self.INITIAL = 1
        self.hidden_layer1 = 5
        self.hidden_layer2 = 2
        self.inputs = 11
        self.gene_number = self.hidden_layer1*self.hidden_layer2+self.hidden_layer1*self.inputs + self.hidden_layer2 + self.hidden_layer1 + self.hidden_layer2 + 1
        self.pop,self.labels = Evolution.create_initial_population(self.POP_SIZE*self.INITIAL,self.gene_number)
#        self.pop[:] = [[-3.57186],[0.34468494],[-0.44975404],[0.37229567],[-0.63908 ],
#                 [-1.88027692],[-0.74647466],[ 1.25289468],[-1.1205533],[-0.00261427],[0]]
        print(self.pop.shape)
#        self.pop[0,:] = -8
#        self.pop[3,:] = 8
        self.nnets = NNets(self.inputs,self.hidden_layer1,self.hidden_layer2)
        self.scores = []
        print('Bot Created')
        self.gen_scores = []
        self.gen_scores_save = []
        self.all_scores=[]
        self.pop_index = 0
        self.iteration_index = 0
        self.weight = self.pop[:,self.pop_index]
        [first,second,out,bias1,bias2,bias3] = self.seperate_weights(self.weight)                
        self.nnets.set_weights_bias(first,second,out,bias1,bias2,bias3)
#        print(self.weight)
        self.new_gen = False
                    
    def best_move(self,tetr):
        position,shape = feature_calc.eval_possible_states_neural(self.matrix,tetr,self.weight,self.nnets)
        #position = int(np.argmax(scores)/4)
        #shape = np.argmax(scores)%4
        if (tetr.name) == 'long':
            position = position
        return (position,shape)
    
    def move_tetr(self,tetr,position,shape):
        moves = []
        #print(position)
        for j in range(shape):
            moves = np.append(moves,'UP')
        
        if tetr.name == 'long' and shape%2 == 1:
            position = position - 2
        elif tetr.name == 'left_gun' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'hat' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'left_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_gun' and shape%4 == 1:
            position = position -1

        if tetr.name == 'square':
            if  position < 4:
                for i in range(4-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-4):
                    moves = np.append(moves,'RIGHT')
        else:
            if  position < 4:
                for i in range(3-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-3):
                    moves = np.append(moves,'RIGHT')
        #moves = np.append(moves,'SPACE')
        #print('Time to move')
        return moves

    def next_agent(self):
        print(self.scores)
        if self.iteration_index == 0:
            if not self.new_gen:
                self.gen_scores = np.append(self.gen_scores,np.mean(self.scores))
                self.gen_scores_save = np.append(self.gen_scores_save,self.scores)
            self.scores = []
            if self.pop_index < self.POP_SIZE*self.INITIAL-1:
                self.pop_index += 1
                self.weight = self.pop[:,self.pop_index]
                [first,second,out,bias1,bias2,bias3] = self.seperate_weights(self.weight)
                self.nnets.set_weights_bias(first,second,out,bias1,bias2,bias3)
                #print(self.weight)
                self.new_gen = False
                #self.weight = np.load('One_best.npy')
                #self.weight = np.load('best_gene.npy')
            else:
                self.next_gen()
        else:
            if not self.new_gen:
                self.gen_scores = np.append(self.gen_scores,np.mean(self.scores))
                self.gen_scores_save = np.append(self.gen_scores_save,self.scores)
            self.scores = []
            if self.pop_index < self.POP_SIZE-1:
                self.pop_index += 1
                self.weight = self.pop[:,self.pop_index]
                self.weight = self.pop[:,self.pop_index]
                [first,second,out,bias1,bias2,bias3] = self.seperate_weights(self.weight)
                self.nnets.set_weights_bias(first,second,out,bias1,bias2,bias3)
#                print(self.weight)
                self.new_gen = False
#                print(self.weight)
                #self.weight = np.load('best_gene_new1.npy')
                #self.weight = np.load('One_best.npy')
            else:
                self.next_gen()
    
    def next_gen(self):
        name_score = 'scores_of_gen' + str(self.iteration_index)
        np.save(name_score,self.gen_scores_save)        
        self.new_gen = True
        if self.iteration_index == 0:
            print('New generation : ', self.iteration_index, ' . Best of previous gen : ',np.max(self.gen_scores), 
                  ' .Average of generation : ', np.mean(self.gen_scores))
            self.iteration_index += 1
            self.pop,self.labels = Evolution.create_next_gen_hard(self.gen_scores,self.pop,1/self.INITIAL,self.labels)
#            self.pop,self.labels = Evolution.create_next_gen(self.gen_scores,self.pop,self.labels)
            self.pop_index = -1
            #self.all_scores = np.append(self.all_scores,self.gen_scores,0)
            self.gen_scores = []
            self.gen_scores_save = []
            self.next_agent()
        
        elif self.iteration_index < self.MAX_ITERATIONS:
            print('New generation : ', self.iteration_index, ' . Best of previous gen : ',np.max(self.gen_scores), 
                  ' .Average of generation : ', np.mean(self.gen_scores))
            self.iteration_index += 1
            self.pop,self.labels = Evolution.create_next_gen(self.gen_scores,self.pop,self.labels)
            self.pop_index = -1
            self.all_scores = np.append(self.all_scores,self.gen_scores,0)
            self.gen_scores = []
            self.gen_scores_save = [] 
            if self.iteration_index % 5 == 0:
                name = 'scores' + str(self.iteration_index)
                np.save(name,self.all_scores)
                name_genes = 'genes' + str(self.iteration_index)
                np.save(name_genes,self.pop)
                name_score = 'scores_for_gen' + str(self.iteration_index)
                np.save(name_score,self.gen_scores)
            self.next_agent()

        else:
            np.save('scores',self.all_scores)
            while True:
                i = 1
        
    def save_score(self,score):
        self.scores = np.append(self.scores,score)
    def seperate_weights(self,weights):
        a = self.hidden_layer1*self.inputs
        b = a+self.hidden_layer1*self.hidden_layer2
        c = b + self.hidden_layer2*1
        inputs_to_first = weights[0:a]
        first_to_second = weights[a:b]
        second_to_out = weights[b:c]
        bias1 = weights[c:c+self.hidden_layer1]
        bias2 = weights[c+self.hidden_layer1:c+self.hidden_layer1+self.hidden_layer2]
        bias3 = weights[c+self.hidden_layer1+self.hidden_layer2]
        return inputs_to_first,first_to_second,second_to_out,bias1,bias2,bias3
    
    def set_matrix(self,matrix):
        self.matrix = matrix

Q_Bot.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Dec 24 22:54:49 2018

@author: redion
"""
import numpy as np
import random
import bot_functions
import feature_calc

class Q_Bot(object):
    
    def __init__(self):
        self.alpha_par=0.1
        self.gamma_par=0.05
        self.eps_par=0.3
        self.iteration =  5
        self.Q_matrix= self.initializeQ_matrix()
        self.matrix = None
        self.old_matrix = None
        self.falling_tetromino = None
        self.last_played_state = 0
        self.last_played_action = 0
        self.score = 0
        self.oldScore = 0
        self.limits = np.array([[0,5],[2,7],[5,10]])
        self.scores = []
    def initializeQ_matrix(self):
        Q_Matrix = np.zeros((9072,20))
        return Q_Matrix
        
    
    def calcReward(self,table):
        old_score = self.calcScore(self.oldScore,self.old_matrix,table)
        new_score = self.calcScore(self.score,self.matrix,table)
        return  4*(self.score-self.oldScore-20) + new_score - old_score - 10
    
    def calcScore(self,score,matrix,table):
        sc = score + feature_calc.partialLine(matrix,self.limits[table][0],self.limits[table][1])-2*feature_calc.average_height(matrix)
        return sc
        
    def setScore(self,score,old):
        if old:
            self.oldScore = score
        else:
            self.score = score        
        
       
    def set_matrix(self,gameMatrix,old):
        gameMatrix = feature_calc.convert2NumpyMatrix(gameMatrix)
        if old:
            self.old_matrix = gameMatrix
        else:
            self.matrix = gameMatrix
        
        
    def findMapping(self,inputvector_size_4):
        for i in range(4):
           if (inputvector_size_4[0,i]==0):
               inputvector_size_4[0,i]=0
           elif(inputvector_size_4[0,i]==1):
               inputvector_size_4[0,i]=1
           elif(inputvector_size_4[0,i]==-1 ):
             inputvector_size_4[0,i]=2
           elif(inputvector_size_4[0,i]==2):
             inputvector_size_4[0,i]=3
           elif(inputvector_size_4[0,i]==-2):
             inputvector_size_4[0,i]=4
           else :
               inputvector_size_4[0,i]=5
            
        return inputvector_size_4
               
    def map_tetromino(self,tetromino):
        tetr_map = 0
        if tetromino.name == 'long':
            tetr_map = 0
        elif tetromino.name == 'square':
            tetr_map = 1
        elif tetromino.name == 'hat':
            tetr_map = 2           
        elif tetromino.name == 'left_snake':
            tetr_map = 3
        elif tetromino.name == 'right_snake':
            tetr_map = 4
        elif tetromino.name == 'left_gun':
            tetr_map = 5
        elif tetromino.name == 'right_gun':
            tetr_map = 6
        return tetr_map

            
    def findtheState(self,stateMatrix,tetromino_unmapped):
        #stateMatrix = feature_calc.convert2NumpyMatrix(stateMatrix)
        dimensions=stateMatrix.shape
        skyline=np.zeros([1,10])
        tetromino = self.map_tetromino(tetromino_unmapped)
        for i in range(dimensions[1]):
           if(np.sum(stateMatrix[:,i])==0):
               skyline[0,i]=0
           else :
                column=stateMatrix[:,i]
                index=column.argmax(axis=0)
                skyline[0,i]=22-index
         #find the difference
        difference_1=np.ediff1d(skyline[0,0:5]).reshape(1,4)
        difference_2=np.ediff1d(skyline[0,2:7]).reshape(1,4)
        difference_3=np.ediff1d(skyline[0,5:10]).reshape(1,4)
        #create the mapping
        difference_1=self.findMapping(difference_1)
        difference_2=self.findMapping(difference_2)
        difference_3=self.findMapping(difference_3)
        stateNumber1=difference_1[0,0]+difference_1[0,1]*6+difference_1[0,2]*36+difference_1[0,3]*216+tetromino*1296
        stateNumber2=difference_2[0,0]+difference_2[0,1]*6+difference_2[0,2]*36+difference_2[0,3]*216+tetromino*1296
        stateNumber3=difference_3[0,0]+difference_3[0,1]*6+difference_3[0,2]*36+difference_3[0,3]*216+tetromino*1296


        return int(stateNumber1),int(stateNumber2),int(stateNumber3)
       
        
    def calculateImmediateReward():
        disp("Calculate immediate Reward")
        
    def isFeasible(self,rotation,column,tetr):
#        print('Feasible')
#        print(tetr.name)
#        print(rotation)
        feas = column<=5-bot_functions.dict_tetr_len[tetr.name][rotation]
        return feas,(rotation%bot_functions.dict_tetr_shape[tetr.name])   
        
    
    def move_tetr(self,tetr,shape,position,table):
        moves = []
        #print(position)
        for j in range(shape):
            moves = np.append(moves,'UP')
        
        
        if tetr.name == 'long' and shape%2 == 1:
            position = position - 2
        elif tetr.name == 'left_gun' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'hat' and shape%4 == 1:
            position = position -1
        elif tetr.name == 'left_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_snake' and shape%2 == 1:
            position = position -1
        elif tetr.name == 'right_gun' and shape%4 == 1:
            position = position -1
        
        if table == 0:
            position = position
        elif table == 1:
            position = position+2
        else:
            position = position + 5

        if tetr.name == 'square':
            if  position < 4:
                for i in range(4-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-4):
                    moves = np.append(moves,'RIGHT')
        else:
            if  position < 4:
                for i in range(3-position):
                    moves = np.append(moves,'LEFT')
            else:
                for i in range(position-3):
                    moves = np.append(moves,'RIGHT')
        #moves = np.append(moves,'SPACE')
        #print('Time to move')
        return moves
    
    def  best_move(self,tetromino):
#         print("Q learning")   
         #hyperparameters
    #     for i in range(10000): #we will check this range
    #     print("Calculate best move")
         #find the state number
         #gameMatrix = feature_calc.convert2NumpyMatrix(self.matrix)
         state_1,state_2,state_3=self.findtheState(self.matrix,tetromino)#change it
         #choose an action (act greedily)
         sampled_number= random.uniform(0,1)
         state_no = 0
         if(sampled_number<self.eps_par):
             ended=False
             while(ended==False):
                 #take a random action 
                 index_action=random.randint(0,19) # take a random action
                 rotation_ToMake = index_action//5
                 column_ToBeSet=index_action%5
                 table = random.randint(0,2)
                 ended,rotation_ToMake = self.isFeasible(rotation_ToMake,column_ToBeSet,tetromino)
         else:
             #take an action
             ended=False
             firstTraverseEnded=False
             while (ended==False):
#                   print(type(self.Q_matrix))
                   max_value=np.max(np.array([self.Q_matrix[state_1,:],self.Q_matrix[state_2,:],
                                              self.Q_matrix[state_3,:]]))
#                   print(max_value)
#                   print(np.nanmax(np.concatenate((self.Q_matrix[state_1,:],
#                                                   self.Q_matrix[state_2,:],
#                                                   self.Q_matrix[state_3,:]))))
##                   print(np.nanmax(self.Q_matrix[state_1,:]))
#                   print(np.nanmax(self.Q_matrix[state_2,:]))
#                   print(np.nanmax(self.Q_matrix[state_3,:]))
                   if (max_value==np.nanmax(self.Q_matrix[state_1,:])):
                       index_action=np.argmax(self.Q_matrix[state_1,:])
                       state_no = state_1
                       table = 0
                   elif (max_value==np.nanmax(self.Q_matrix[state_2,:])):
                       index_action=np.argmax(self.Q_matrix[state_2,:])
                       state_no = state_2
                       table = 1
                   elif  (max_value==np.nanmax(self.Q_matrix[state_3,:])):
                       index_action=np.argmax(self.Q_matrix[state_3,:])
                       state_no = state_3
                       table = 2
                   else:
                        print('Error')
                   rotation_ToMake= index_action//5
                   column_ToBeSet=index_action%5
                   ended,rotation_ToMake = self.isFeasible(rotation_ToMake,column_ToBeSet,tetromino)
                   if not ended:
                       self.Q_matrix[state_no,index_action]  =  -10
         self.last_played_action = index_action
         self.last_played_state = state_no
         return rotation_ToMake,column_ToBeSet,table
         #find the next state by using that action
    
    def update_Q_matrix(self,table,tetromino,reward_next):
             alpha_par = self.alpha_par
             gamma_par = self.gamma_par
             next_states=self.findtheState(self.matrix,tetromino) # bu da bizim findstate'le mi yapacaz ?   #change these     
             next_state = next_states[table]
         #   reward_next = self.calculateImmediateReward()
         #do the sample estimate
             sample_estimate=alpha_par * (reward_next + gamma_par * np.max(self.Q_matrix[next_state,:]))
         #update the Q-values
             self.Q_matrix[self.last_played_state,self.last_played_action] = (1-alpha_par)*self.Q_matrix[self.last_played_state,self.last_played_action]+sample_estimate
             self.iteration = self.iteration + 1
             if(self.iteration%50000 == 0):
                  print(np.nonzero(self.Q_matrix))
                  ind = np.flatnonzero(self.Q_matrix)
                  print(self.Q_matrix[ind//20,ind%20])
                  if(self.iteration%100000 == 0):
                      name = 'qmatrix'+ str(self.iteration)+'.txt'
                      np.savetxt(name,self.Q_matrix)
                      name = 'scores' + str(self.iteration)+'.txt'
                      np.savetxt(name,self.scores)
#             print(np.min(self.Q_matrix))

        
    def save_score(self,score):
        self.scores = np.append(self.scores,score)
        
Evolution.py


import feature_calc
import numpy as np


def create_initial_population(pop_size,genes):
    initial = np.random.uniform(-2.5,2.5,(genes,pop_size))
    labels = []
    for i in range(pop_size):
        labels = np.append(labels,str(i))
    return (initial,labels)

def create_next_gen(scores,pop,labels):
    print(labels)
    print(scores)
    elitist_select,labels1 = selection(scores,pop,0.4,labels)
    next_gen = elitist_select
    next_labels = labels1
    co_select,co_labels = crossover(scores,pop,0.2,labels)
    next_gen = np.append(next_gen,co_select,axis=1)
    next_labels = np.append(next_labels,co_labels)
    mut,mut_lab = mutation(elitist_select,labels1)
    next_gen = np.append(next_gen,mut,axis=1)
    next_labels = np.append(next_labels,mut_lab)
    return next_gen,next_labels

def create_next_gen_hard(scores,pop,hardness,labels):
    print(labels)
    print(scores)

    elitist_select,labels1 = selection(scores,pop,0.4*hardness,labels)
    next_gen = elitist_select
    next_labels = labels1
    co_select,co_labels = crossover(scores,pop,0.2*hardness,labels)
    next_gen = np.append(next_gen,co_select,axis=1)
    next_labels = np.append(next_labels,co_labels)
    mut,mut_lab = mutation(elitist_select,labels1)
    next_gen = np.append(next_gen,mut,axis=1)
    next_labels = np.append(next_labels,mut_lab)
    return next_gen,next_labels

def mutation(pop,labels):
    ## Partial
    #return pop + np.random.uniform(-0.4,0.4,(pop.shape))
    # Substitute
    a = np.random.uniform(0,1,(pop.shape))
    mut = np.random.uniform(-2.5,2.5,(pop.shape))
    #ind = (a < 0.5)
    ind_pop = (a >= 0.5)
    mutants = pop*ind_pop + mut#*ind
    for i in range(labels.size):  
        labels[i] = labels[i] +  'm'

    return (mutants,labels)

    
def selection(scores,pop,elitism,labels,gene = 11):
    ind = scores.argsort()[-int((np.floor(elitism*len(scores)))):]
    selected = pop[:,ind]
    sel_labels = labels[ind]
    selected = selected.reshape(gene,-1)
    return (selected,sel_labels)

def crossover(scores, pop, co_slct,labels):

    parents,co_labels = selection(scores,pop,co_slct,labels)
    a1 = np.random.uniform(0,1,(parents.shape))
    a2 = 1 - a1
    ## Averaging
#   children = (np.transpose(parents*a1) + np.random.permutation(np.transpose(parents*a2)))
    children = np.transpose(parents*a1) + np.transpose(parents*a2)[::-1]
#    a = np.random.uniform(0,1,(parents.shape))
#    ind = (a < 0.5)
#    ind_c = (a >= 0.5)    
#    children = (np.transpose(parents*ind) + np.random.permutation(np.transpose(parents*ind_c)))
    q = np.transpose(children)
    for i in range(co_labels.size):  
        co_labels[i] = co_labels[i] +  'c'
    return (q,co_labels)

    
NNets.py

# -*- coding: utf-8 -*-
"""
Created on Mon Dec 24 19:23:31 2018

@author: Alperen
"""
import numpy as np

class NNets(object):
    def __init__(self,inputs,hidden1,hidden2):
        # inputs_train= random_image_train.flatten()/255  code sample
        self.dimensions=[inputs,hidden1,hidden2,1] #
        numberofLayer=3
        self.model = []
    #   learning_rate=0.1

    def sigmoid(x):
        return 1 / (1 + np.exp(-x))
    # derivative of sigmoid
    #def tanh_derivative():
    def tanhPrime(input_1):
        output= 1.0 - input_1**2 
        return output
    
    
    #def sigmoid_derivative():
        #the input should  be sigmoided  value
    def sigmoidPrime(input_1):
         output=input_1(1-input_1)
         return output
    def set_weights_bias(self,weights1,weights2,weights3,bias1,bias2,bias3):
       #numberOfLayers will be an integer starting from 2
       #nodesNumberForEachLayer will be an 1 by numberOfLayers vector
       #create a list which stores weights and bias
       model={}
       i=1

       model["bias" + str(i)]= bias1
       model["Weights" + str(i)]= weights1
       i=2
       model["bias" + str(i)]= bias2
       model["Weights" + str(i)]= weights2
       i=3
       model["bias" + str(i)]= bias3
       model["Weights" + str(i)]= weights3
       self.model = model
       return True
    
    #the forware propagation method (returns Z_l and A_L)
    def forward_prop(self,nonlinearFunction,a0,noLayers):
        memory={}  #it will store a-s and z-s which are needed for backpropagation
        memory["a0"]=a0
        #retrieve the particular weights
        for i in range(1,noLayers+1):
        #   Y=WX+b

            memory["z"+ str(i)]=np.dot(self.model["Weights" + str(i)].reshape(-1,self.dimensions[i-1]),
                  memory["a" + str(i-1)].reshape(-1,1))+self.model["bias" + str(i)].reshape(-1,1)
            # output=f(Y) (nonlinear function)
            if i == noLayers:
                memory["a"+ str(i)]= memory["z"+ str(i)]
            elif nonlinearFunction == "tanh":
                memory["a"+ str(i)]=np.tanh( memory["z"+ str(i)])
            elif nonlinearFunction == "sigmoid":
                memory["a"+ str(i)]= 1/(1 + np.exp(-memory["z"+ str(i)]))
        self.memory = memory
        return memory["a"+ str(noLayers)]






